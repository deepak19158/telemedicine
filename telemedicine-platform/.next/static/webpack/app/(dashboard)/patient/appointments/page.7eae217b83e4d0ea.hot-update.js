"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/patient/appointments/page",{

/***/ "(app-pages-browser)/./lib/hooks/useApi.ts":
/*!*****************************!*\
  !*** ./lib/hooks/useApi.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAdminUsers: function() { return /* binding */ useAdminUsers; },\n/* harmony export */   useApi: function() { return /* binding */ useApi; },\n/* harmony export */   useApiMutation: function() { return /* binding */ useApiMutation; },\n/* harmony export */   useApproveDoctor: function() { return /* binding */ useApproveDoctor; },\n/* harmony export */   useDoctorAvailability: function() { return /* binding */ useDoctorAvailability; },\n/* harmony export */   useDoctorProfile: function() { return /* binding */ useDoctorProfile; },\n/* harmony export */   useDoctorSearch: function() { return /* binding */ useDoctorSearch; },\n/* harmony export */   useLoadingTimeout: function() { return /* binding */ useLoadingTimeout; },\n/* harmony export */   usePagination: function() { return /* binding */ usePagination; },\n/* harmony export */   usePendingDoctors: function() { return /* binding */ usePendingDoctors; },\n/* harmony export */   useRegisterDoctor: function() { return /* binding */ useRegisterDoctor; },\n/* harmony export */   useSearch: function() { return /* binding */ useSearch; },\n/* harmony export */   useSpecializations: function() { return /* binding */ useSpecializations; },\n/* harmony export */   useUpdateDoctorAvailability: function() { return /* binding */ useUpdateDoctorAvailability; },\n/* harmony export */   useUpdateDoctorProfile: function() { return /* binding */ useUpdateDoctorProfile; },\n/* harmony export */   useUpdateUserProfile: function() { return /* binding */ useUpdateUserProfile; },\n/* harmony export */   useUpdateUserStatus: function() { return /* binding */ useUpdateUserStatus; },\n/* harmony export */   useUploadAvatar: function() { return /* binding */ useUploadAvatar; },\n/* harmony export */   useUserAnalytics: function() { return /* binding */ useUserAnalytics; },\n/* harmony export */   useUserProfile: function() { return /* binding */ useUserProfile; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _api_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api-client */ \"(app-pages-browser)/./lib/api-client.ts\");\n\n\n// Generic hook for API calls\nfunction useApi(apiCall) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { immediate = true, onSuccess, onError, timeout = 30000, enabled = true } = options;\n    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [timedOut, setTimedOut] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loadingStartTime, setLoadingStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!enabled) return;\n        try {\n            console.log(\"\\uD83D\\uDD04 Starting API call...\") // Debug log\n            ;\n            // Cancel previous request if it exists\n            if (abortController) {\n                abortController.abort();\n            }\n            const newAbortController = new AbortController();\n            setAbortController(newAbortController);\n            setLoading(true);\n            setError(null);\n            setTimedOut(false);\n            setLoadingStartTime(Date.now());\n            // Create timeout promise\n            const timeoutPromise = new Promise((_, reject)=>{\n                setTimeout(()=>{\n                    setTimedOut(true);\n                    reject(new Error(\"Request timeout - please check your connection\"));\n                }, timeout);\n            });\n            // Race between API call and timeout\n            const response = await Promise.race([\n                apiCall(),\n                timeoutPromise\n            ]);\n            // Check if request was aborted\n            if (newAbortController.signal.aborted) {\n                console.log(\"\\uD83D\\uDEAB Request was aborted\") // Debug log\n                ;\n                return;\n            }\n            console.log(\"✅ API call response:\", response) // Debug log\n            ;\n            if (response.success) {\n                setData(response.data);\n                onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(response.data);\n                console.log(\"✅ API call successful, data set\") // Debug log\n                ;\n            } else {\n                const errorMsg = response.error || \"Unknown error occurred\";\n                setError(errorMsg);\n                onError === null || onError === void 0 ? void 0 : onError(errorMsg);\n                console.log(\"❌ API call failed:\", errorMsg) // Debug log\n                ;\n            }\n        } catch (err) {\n            if (err instanceof Error && err.name === \"AbortError\") {\n                console.log(\"\\uD83D\\uDEAB Request was aborted\") // Debug log\n                ;\n                return;\n            }\n            const errorMessage = err instanceof Error ? err.message : \"Network error\";\n            setError(errorMessage);\n            onError === null || onError === void 0 ? void 0 : onError(errorMessage);\n            console.log(\"\\uD83D\\uDCA5 API call error:\", errorMessage) // Debug log\n            ;\n        } finally{\n            setLoading(false);\n            setAbortController(null);\n            console.log(\"\\uD83C\\uDFC1 API call finished, loading set to false\") // Debug log\n            ;\n        }\n    }, [\n        enabled,\n        timeout\n    ]) // Removed apiCall, onSuccess, onError from dependencies to prevent infinite loops\n    ;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (immediate && enabled) {\n            console.log(\"\\uD83D\\uDE80 useEffect triggered, calling fetchData\") // Debug log\n            ;\n            fetchData();\n        }\n        // Cleanup function to abort ongoing requests\n        return ()=>{\n            if (abortController) {\n                abortController.abort();\n            }\n        };\n    }, [\n        immediate,\n        enabled\n    ]) // Removed fetchData from dependencies\n    ;\n    return {\n        data,\n        loading,\n        error,\n        refetch: fetchData,\n        timedOut\n    };\n}\n// Hook for handling loading timeouts\nfunction useLoadingTimeout(isLoading) {\n    let timeoutMs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10000;\n    const [hasTimedOut, setHasTimedOut] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isLoading) {\n            setHasTimedOut(false);\n            return;\n        }\n        const timer = setTimeout(()=>{\n            setHasTimedOut(true);\n            console.log(\"⏰ Loading timeout reached after\", timeoutMs, \"ms\");\n        }, timeoutMs);\n        return ()=>clearTimeout(timer);\n    }, [\n        isLoading,\n        timeoutMs\n    ]);\n    return hasTimedOut;\n}\n// Hook for mutations (POST, PUT, DELETE)\nfunction useApiMutation(mutationFn) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const mutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (variables)=>{\n        try {\n            setLoading(true);\n            setError(null);\n            const response = await mutationFn(variables);\n            if (response.success) {\n                var _options_onSuccess;\n                (_options_onSuccess = options.onSuccess) === null || _options_onSuccess === void 0 ? void 0 : _options_onSuccess.call(options, response.data);\n                return response.data;\n            } else {\n                var _options_onError;\n                setError(response.error || \"Unknown error occurred\");\n                (_options_onError = options.onError) === null || _options_onError === void 0 ? void 0 : _options_onError.call(options, response.error || \"Unknown error occurred\");\n                throw new Error(response.error);\n            }\n        } catch (err) {\n            var _options_onError1;\n            const errorMessage = err instanceof Error ? err.message : \"Network error\";\n            setError(errorMessage);\n            (_options_onError1 = options.onError) === null || _options_onError1 === void 0 ? void 0 : _options_onError1.call(options, errorMessage);\n            throw err;\n        } finally{\n            setLoading(false);\n        }\n    }, [\n        mutationFn,\n        options\n    ]);\n    return {\n        mutate,\n        loading,\n        error,\n        reset: ()=>setError(null)\n    };\n}\n// Specific hooks for common API calls\n// User Profile Hooks\nfunction useUserProfile() {\n    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const { enabled = true } = options;\n    return useApi(()=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.user.getProfile(), {\n        enabled,\n        timeout: 15000,\n        onSuccess: (data)=>{\n            console.log(\"\\uD83D\\uDC64 User profile loaded successfully:\", data);\n        },\n        onError: (error)=>{\n            console.log(\"\\uD83D\\uDC64 User profile failed to load:\", error);\n        }\n    });\n}\nfunction useUpdateUserProfile() {\n    return useApiMutation((profileData)=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.user.updateProfile(profileData));\n}\nfunction useUploadAvatar() {\n    return useApiMutation((file)=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.user.uploadAvatar(file));\n}\n// Doctor Profile Hooks\nfunction useDoctorProfile() {\n    return useApi(()=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.doctor.getProfile());\n}\nfunction useUpdateDoctorProfile() {\n    return useApiMutation((profileData)=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.doctor.updateProfile(profileData));\n}\nfunction useDoctorAvailability() {\n    return useApi(()=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.doctor.getAvailability());\n}\nfunction useUpdateDoctorAvailability() {\n    return useApiMutation((availabilityData)=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.doctor.updateAvailability(availabilityData));\n}\n// Doctor Search Hook\nfunction useDoctorSearch() {\n    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return useApi(()=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.doctor.search(params), {\n        immediate: Object.keys(params).length > 0\n    });\n}\n// Specializations Hook\nfunction useSpecializations() {\n    return useApi(()=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.doctor.getSpecializations());\n}\n// Admin Hooks\nfunction useAdminUsers() {\n    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return useApi(()=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.admin.getUsers(params));\n}\nfunction useUpdateUserStatus() {\n    return useApiMutation((data)=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.admin.updateUserStatus(data.userId, data.isActive, data.reason));\n}\nfunction useUserAnalytics(period) {\n    return useApi(()=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.admin.getUserAnalytics(period));\n}\nfunction usePendingDoctors() {\n    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return useApi(()=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.admin.getPendingDoctors(params));\n}\nfunction useApproveDoctor() {\n    return useApiMutation((data)=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.admin.approveDoctor(data.doctorId, data.action, data.reason, data.assignPatients));\n}\n// Doctor Registration Hook\nfunction useRegisterDoctor() {\n    return useApiMutation((doctorData)=>_api_client__WEBPACK_IMPORTED_MODULE_1__.apiClient.doctor.register(doctorData));\n}\n// Helper hook for pagination\nfunction usePagination() {\n    let initialPage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, initialLimit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    const [page, setPage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialPage);\n    const [limit, setLimit] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialLimit);\n    const nextPage = ()=>setPage((prev)=>prev + 1);\n    const prevPage = ()=>setPage((prev)=>Math.max(1, prev - 1));\n    const goToPage = (newPage)=>setPage(Math.max(1, newPage));\n    const changeLimit = (newLimit)=>{\n        setLimit(newLimit);\n        setPage(1) // Reset to first page when changing limit\n        ;\n    };\n    return {\n        page,\n        limit,\n        nextPage,\n        prevPage,\n        goToPage,\n        changeLimit,\n        params: {\n            page: page.toString(),\n            limit: limit.toString()\n        }\n    };\n}\n// Helper hook for search\nfunction useSearch() {\n    let initialQuery = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    const [query, setQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialQuery);\n    const [debouncedQuery, setDebouncedQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialQuery);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const timer = setTimeout(()=>{\n            setDebouncedQuery(query);\n        }, 300) // 300ms debounce\n        ;\n        return ()=>clearTimeout(timer);\n    }, [\n        query\n    ]);\n    return {\n        query,\n        debouncedQuery,\n        setQuery,\n        clearQuery: ()=>setQuery(\"\")\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9ob29rcy91c2VBcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDRjtBQWlCdEQsNkJBQTZCO0FBQ3RCLFNBQVNJLE9BQ2RDLE9BQXNDO1FBQ3RDQyxVQUFBQSxpRUFBeUIsQ0FBQztJQUUxQixNQUFNLEVBQ0pDLFlBQVksSUFBSSxFQUNoQkMsU0FBUyxFQUNUQyxPQUFPLEVBQ1BDLFVBQVUsS0FBSyxFQUNmQyxVQUFVLElBQUksRUFDZixHQUFHTDtJQUVKLE1BQU0sQ0FBQ00sTUFBTUMsUUFBUSxHQUFHYiwrQ0FBUUEsQ0FBVztJQUMzQyxNQUFNLENBQUNjLFNBQVNDLFdBQVcsR0FBR2YsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDZ0IsT0FBT0MsU0FBUyxHQUFHakIsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU0sQ0FBQ2tCLFVBQVVDLFlBQVksR0FBR25CLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQ29CLGlCQUFpQkMsbUJBQW1CLEdBQUdyQiwrQ0FBUUEsQ0FBeUI7SUFDL0UsTUFBTSxDQUFDc0Isa0JBQWtCQyxvQkFBb0IsR0FBR3ZCLCtDQUFRQSxDQUFnQjtJQUV4RSxNQUFNd0IsWUFBWXRCLGtEQUFXQSxDQUFDO1FBQzVCLElBQUksQ0FBQ1MsU0FBUztRQUVkLElBQUk7WUFDRmMsUUFBUUMsR0FBRyxDQUFDLHFDQUEyQixZQUFZOztZQUVuRCx1Q0FBdUM7WUFDdkMsSUFBSU4saUJBQWlCO2dCQUNuQkEsZ0JBQWdCTyxLQUFLO1lBQ3ZCO1lBRUEsTUFBTUMscUJBQXFCLElBQUlDO1lBQy9CUixtQkFBbUJPO1lBRW5CYixXQUFXO1lBQ1hFLFNBQVM7WUFDVEUsWUFBWTtZQUNaSSxvQkFBb0JPLEtBQUtDLEdBQUc7WUFFNUIseUJBQXlCO1lBQ3pCLE1BQU1DLGlCQUFpQixJQUFJQyxRQUFRLENBQUNDLEdBQUdDO2dCQUNyQ0MsV0FBVztvQkFDVGpCLFlBQVk7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QyxRQUFRO1lBQUUrQixNQUFNQSxLQUFLYSxRQUFRO1lBQUlYLE9BQU9BLE1BQU1XLFFBQVE7UUFBRztJQUMzRDtBQUNGO0FBRUEseUJBQXlCO0FBQ2xCLFNBQVNDO1FBQVVDLGVBQUFBLGlFQUFlO0lBQ3ZDLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHL0gsK0NBQVFBLENBQUM2SDtJQUNuQyxNQUFNLENBQUNHLGdCQUFnQkMsa0JBQWtCLEdBQUdqSSwrQ0FBUUEsQ0FBQzZIO0lBRXJENUgsZ0RBQVNBLENBQUM7UUFDUixNQUFNcUQsUUFBUWxCLFdBQVc7WUFDdkI2RixrQkFBa0JIO1FBQ3BCLEdBQUcsS0FBSyxpQkFBaUI7O1FBRXpCLE9BQU8sSUFBTXZFLGFBQWFEO0lBQzVCLEdBQUc7UUFBQ3dFO0tBQU07SUFFVixPQUFPO1FBQ0xBO1FBQ0FFO1FBQ0FEO1FBQ0FHLFlBQVksSUFBTUgsU0FBUztJQUM3QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9ob29rcy91c2VBcGkudHM/MzNlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgYXBpQ2xpZW50LCBBcGlSZXNwb25zZSB9IGZyb20gJy4uL2FwaS1jbGllbnQnXG5cbmludGVyZmFjZSBVc2VBcGlTdGF0ZTxUPiB7XG4gIGRhdGE6IFQgfCBudWxsXG4gIGxvYWRpbmc6IGJvb2xlYW5cbiAgZXJyb3I6IHN0cmluZyB8IG51bGxcbiAgcmVmZXRjaDogKCkgPT4gUHJvbWlzZTx2b2lkPlxufVxuXG5pbnRlcmZhY2UgVXNlQXBpT3B0aW9ucyB7XG4gIGltbWVkaWF0ZT86IGJvb2xlYW5cbiAgb25TdWNjZXNzPzogKGRhdGE6IGFueSkgPT4gdm9pZFxuICBvbkVycm9yPzogKGVycm9yOiBzdHJpbmcpID0+IHZvaWRcbiAgdGltZW91dD86IG51bWJlclxuICBlbmFibGVkPzogYm9vbGVhblxufVxuXG4vLyBHZW5lcmljIGhvb2sgZm9yIEFQSSBjYWxsc1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFwaTxUPihcbiAgYXBpQ2FsbDogKCkgPT4gUHJvbWlzZTxBcGlSZXNwb25zZTxUPj4sXG4gIG9wdGlvbnM6IFVzZUFwaU9wdGlvbnMgPSB7fVxuKTogVXNlQXBpU3RhdGU8VD4ge1xuICBjb25zdCB7IFxuICAgIGltbWVkaWF0ZSA9IHRydWUsIFxuICAgIG9uU3VjY2VzcywgXG4gICAgb25FcnJvciwgXG4gICAgdGltZW91dCA9IDMwMDAwLCAvLyAzMCBzZWNvbmQgdGltZW91dFxuICAgIGVuYWJsZWQgPSB0cnVlIFxuICB9ID0gb3B0aW9uc1xuICBcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gdXNlU3RhdGU8VCB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFt0aW1lZE91dCwgc2V0VGltZWRPdXRdID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFthYm9ydENvbnRyb2xsZXIsIHNldEFib3J0Q29udHJvbGxlcl0gPSB1c2VTdGF0ZTxBYm9ydENvbnRyb2xsZXIgfCBudWxsPihudWxsKVxuICBjb25zdCBbbG9hZGluZ1N0YXJ0VGltZSwgc2V0TG9hZGluZ1N0YXJ0VGltZV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKVxuXG4gIGNvbnN0IGZldGNoRGF0YSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVyblxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBTdGFydGluZyBBUEkgY2FsbC4uLicpIC8vIERlYnVnIGxvZ1xuICAgICAgXG4gICAgICAvLyBDYW5jZWwgcHJldmlvdXMgcmVxdWVzdCBpZiBpdCBleGlzdHNcbiAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgbmV3QWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIobmV3QWJvcnRDb250cm9sbGVyKVxuICAgICAgXG4gICAgICBzZXRMb2FkaW5nKHRydWUpXG4gICAgICBzZXRFcnJvcihudWxsKVxuICAgICAgc2V0VGltZWRPdXQoZmFsc2UpXG4gICAgICBzZXRMb2FkaW5nU3RhcnRUaW1lKERhdGUubm93KCkpXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSB0aW1lb3V0IHByb21pc2VcbiAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBzZXRUaW1lZE91dCh0cnVlKVxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZW91dCAtIHBsZWFzZSBjaGVjayB5b3VyIGNvbm5lY3Rpb24nKSlcbiAgICAgICAgfSwgdGltZW91dClcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIFJhY2UgYmV0d2VlbiBBUEkgY2FsbCBhbmQgdGltZW91dFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICBhcGlDYWxsKCksXG4gICAgICAgIHRpbWVvdXRQcm9taXNlXG4gICAgICBdKSBhcyBBcGlSZXNwb25zZTxUPlxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiByZXF1ZXN0IHdhcyBhYm9ydGVkXG4gICAgICBpZiAobmV3QWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5qrIFJlcXVlc3Qgd2FzIGFib3J0ZWQnKSAvLyBEZWJ1ZyBsb2dcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgQVBJIGNhbGwgcmVzcG9uc2U6JywgcmVzcG9uc2UpIC8vIERlYnVnIGxvZ1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICBzZXREYXRhKHJlc3BvbnNlLmRhdGEpXG4gICAgICAgIG9uU3VjY2Vzcz8uKHJlc3BvbnNlLmRhdGEpXG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgQVBJIGNhbGwgc3VjY2Vzc2Z1bCwgZGF0YSBzZXQnKSAvLyBEZWJ1ZyBsb2dcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yTXNnID0gcmVzcG9uc2UuZXJyb3IgfHwgJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnXG4gICAgICAgIHNldEVycm9yKGVycm9yTXNnKVxuICAgICAgICBvbkVycm9yPy4oZXJyb3JNc2cpXG4gICAgICAgIGNvbnNvbGUubG9nKCfinYwgQVBJIGNhbGwgZmFpbGVkOicsIGVycm9yTXNnKSAvLyBEZWJ1ZyBsb2dcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5qrIFJlcXVlc3Qgd2FzIGFib3J0ZWQnKSAvLyBEZWJ1ZyBsb2dcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnTmV0d29yayBlcnJvcidcbiAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSlcbiAgICAgIG9uRXJyb3I/LihlcnJvck1lc3NhZ2UpXG4gICAgICBjb25zb2xlLmxvZygn8J+SpSBBUEkgY2FsbCBlcnJvcjonLCBlcnJvck1lc3NhZ2UpIC8vIERlYnVnIGxvZ1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpXG4gICAgICBjb25zb2xlLmxvZygn8J+PgSBBUEkgY2FsbCBmaW5pc2hlZCwgbG9hZGluZyBzZXQgdG8gZmFsc2UnKSAvLyBEZWJ1ZyBsb2dcbiAgICB9XG4gIH0sIFtlbmFibGVkLCB0aW1lb3V0XSkgLy8gUmVtb3ZlZCBhcGlDYWxsLCBvblN1Y2Nlc3MsIG9uRXJyb3IgZnJvbSBkZXBlbmRlbmNpZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGltbWVkaWF0ZSAmJiBlbmFibGVkKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+agCB1c2VFZmZlY3QgdHJpZ2dlcmVkLCBjYWxsaW5nIGZldGNoRGF0YScpIC8vIERlYnVnIGxvZ1xuICAgICAgZmV0Y2hEYXRhKClcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW51cCBmdW5jdGlvbiB0byBhYm9ydCBvbmdvaW5nIHJlcXVlc3RzXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpbW1lZGlhdGUsIGVuYWJsZWRdKSAvLyBSZW1vdmVkIGZldGNoRGF0YSBmcm9tIGRlcGVuZGVuY2llc1xuXG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBsb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIHJlZmV0Y2g6IGZldGNoRGF0YSxcbiAgICB0aW1lZE91dFxuICB9XG59XG5cbi8vIEhvb2sgZm9yIGhhbmRsaW5nIGxvYWRpbmcgdGltZW91dHNcbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2FkaW5nVGltZW91dChpc0xvYWRpbmc6IGJvb2xlYW4sIHRpbWVvdXRNczogbnVtYmVyID0gMTAwMDApIHtcbiAgY29uc3QgW2hhc1RpbWVkT3V0LCBzZXRIYXNUaW1lZE91dF0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0xvYWRpbmcpIHtcbiAgICAgIHNldEhhc1RpbWVkT3V0KGZhbHNlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRIYXNUaW1lZE91dCh0cnVlKVxuICAgICAgY29uc29sZS5sb2coJ+KPsCBMb2FkaW5nIHRpbWVvdXQgcmVhY2hlZCBhZnRlcicsIHRpbWVvdXRNcywgJ21zJylcbiAgICB9LCB0aW1lb3V0TXMpXG4gICAgXG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lcilcbiAgfSwgW2lzTG9hZGluZywgdGltZW91dE1zXSlcbiAgXG4gIHJldHVybiBoYXNUaW1lZE91dFxufVxuXG4vLyBIb29rIGZvciBtdXRhdGlvbnMgKFBPU1QsIFBVVCwgREVMRVRFKVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFwaU11dGF0aW9uPFREYXRhLCBUVmFyaWFibGVzID0gYW55PihcbiAgbXV0YXRpb25GbjogKHZhcmlhYmxlczogVFZhcmlhYmxlcykgPT4gUHJvbWlzZTxBcGlSZXNwb25zZTxURGF0YT4+LFxuICBvcHRpb25zOiB7XG4gICAgb25TdWNjZXNzPzogKGRhdGE6IFREYXRhKSA9PiB2b2lkXG4gICAgb25FcnJvcj86IChlcnJvcjogc3RyaW5nKSA9PiB2b2lkXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXG5cbiAgY29uc3QgbXV0YXRlID0gdXNlQ2FsbGJhY2soYXN5bmMgKHZhcmlhYmxlczogVFZhcmlhYmxlcykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpXG4gICAgICBzZXRFcnJvcihudWxsKVxuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG11dGF0aW9uRm4odmFyaWFibGVzKVxuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICBvcHRpb25zLm9uU3VjY2Vzcz8uKHJlc3BvbnNlLmRhdGEpXG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRFcnJvcihyZXNwb25zZS5lcnJvciB8fCAnVW5rbm93biBlcnJvciBvY2N1cnJlZCcpXG4gICAgICAgIG9wdGlvbnMub25FcnJvcj8uKHJlc3BvbnNlLmVycm9yIHx8ICdVbmtub3duIGVycm9yIG9jY3VycmVkJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdOZXR3b3JrIGVycm9yJ1xuICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgICAgb3B0aW9ucy5vbkVycm9yPy4oZXJyb3JNZXNzYWdlKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpXG4gICAgfVxuICB9LCBbbXV0YXRpb25Gbiwgb3B0aW9uc10pXG5cbiAgcmV0dXJuIHtcbiAgICBtdXRhdGUsXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICByZXNldDogKCkgPT4gc2V0RXJyb3IobnVsbClcbiAgfVxufVxuXG4vLyBTcGVjaWZpYyBob29rcyBmb3IgY29tbW9uIEFQSSBjYWxsc1xuXG4vLyBVc2VyIFByb2ZpbGUgSG9va3NcbmV4cG9ydCBmdW5jdGlvbiB1c2VVc2VyUHJvZmlsZShvcHRpb25zOiB7IGVuYWJsZWQ/OiBib29sZWFuIH0gPSB7fSkge1xuICBjb25zdCB7IGVuYWJsZWQgPSB0cnVlIH0gPSBvcHRpb25zXG4gIFxuICByZXR1cm4gdXNlQXBpKCgpID0+IGFwaUNsaWVudC51c2VyLmdldFByb2ZpbGUoKSwge1xuICAgIGVuYWJsZWQsXG4gICAgdGltZW91dDogMTUwMDAsIC8vIDE1IHNlY29uZCB0aW1lb3V0IGZvciBwcm9maWxlXG4gICAgb25TdWNjZXNzOiAoZGF0YSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ/CfkaQgVXNlciBwcm9maWxlIGxvYWRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YSlcbiAgICB9LFxuICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ/CfkaQgVXNlciBwcm9maWxlIGZhaWxlZCB0byBsb2FkOicsIGVycm9yKVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVwZGF0ZVVzZXJQcm9maWxlKCkge1xuICByZXR1cm4gdXNlQXBpTXV0YXRpb24oKHByb2ZpbGVEYXRhOiBhbnkpID0+IFxuICAgIGFwaUNsaWVudC51c2VyLnVwZGF0ZVByb2ZpbGUocHJvZmlsZURhdGEpXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVwbG9hZEF2YXRhcigpIHtcbiAgcmV0dXJuIHVzZUFwaU11dGF0aW9uKChmaWxlOiBGaWxlKSA9PiBcbiAgICBhcGlDbGllbnQudXNlci51cGxvYWRBdmF0YXIoZmlsZSlcbiAgKVxufVxuXG4vLyBEb2N0b3IgUHJvZmlsZSBIb29rc1xuZXhwb3J0IGZ1bmN0aW9uIHVzZURvY3RvclByb2ZpbGUoKSB7XG4gIHJldHVybiB1c2VBcGkoKCkgPT4gYXBpQ2xpZW50LmRvY3Rvci5nZXRQcm9maWxlKCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VVcGRhdGVEb2N0b3JQcm9maWxlKCkge1xuICByZXR1cm4gdXNlQXBpTXV0YXRpb24oKHByb2ZpbGVEYXRhOiBhbnkpID0+IFxuICAgIGFwaUNsaWVudC5kb2N0b3IudXBkYXRlUHJvZmlsZShwcm9maWxlRGF0YSlcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRG9jdG9yQXZhaWxhYmlsaXR5KCkge1xuICByZXR1cm4gdXNlQXBpKCgpID0+IGFwaUNsaWVudC5kb2N0b3IuZ2V0QXZhaWxhYmlsaXR5KCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VVcGRhdGVEb2N0b3JBdmFpbGFiaWxpdHkoKSB7XG4gIHJldHVybiB1c2VBcGlNdXRhdGlvbigoYXZhaWxhYmlsaXR5RGF0YTogYW55KSA9PiBcbiAgICBhcGlDbGllbnQuZG9jdG9yLnVwZGF0ZUF2YWlsYWJpbGl0eShhdmFpbGFiaWxpdHlEYXRhKVxuICApXG59XG5cbi8vIERvY3RvciBTZWFyY2ggSG9va1xuZXhwb3J0IGZ1bmN0aW9uIHVzZURvY3RvclNlYXJjaChwYXJhbXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSkge1xuICByZXR1cm4gdXNlQXBpKCgpID0+IGFwaUNsaWVudC5kb2N0b3Iuc2VhcmNoKHBhcmFtcyksIHtcbiAgICBpbW1lZGlhdGU6IE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID4gMFxuICB9KVxufVxuXG4vLyBTcGVjaWFsaXphdGlvbnMgSG9va1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNwZWNpYWxpemF0aW9ucygpIHtcbiAgcmV0dXJuIHVzZUFwaSgoKSA9PiBhcGlDbGllbnQuZG9jdG9yLmdldFNwZWNpYWxpemF0aW9ucygpKVxufVxuXG4vLyBBZG1pbiBIb29rc1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFkbWluVXNlcnMocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30pIHtcbiAgcmV0dXJuIHVzZUFwaSgoKSA9PiBhcGlDbGllbnQuYWRtaW4uZ2V0VXNlcnMocGFyYW1zKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVwZGF0ZVVzZXJTdGF0dXMoKSB7XG4gIHJldHVybiB1c2VBcGlNdXRhdGlvbigoZGF0YTogeyB1c2VySWQ6IHN0cmluZzsgaXNBY3RpdmU6IGJvb2xlYW47IHJlYXNvbj86IHN0cmluZyB9KSA9PiBcbiAgICBhcGlDbGllbnQuYWRtaW4udXBkYXRlVXNlclN0YXR1cyhkYXRhLnVzZXJJZCwgZGF0YS5pc0FjdGl2ZSwgZGF0YS5yZWFzb24pXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVzZXJBbmFseXRpY3MocGVyaW9kPzogc3RyaW5nKSB7XG4gIHJldHVybiB1c2VBcGkoKCkgPT4gYXBpQ2xpZW50LmFkbWluLmdldFVzZXJBbmFseXRpY3MocGVyaW9kKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBlbmRpbmdEb2N0b3JzKHBhcmFtczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9KSB7XG4gIHJldHVybiB1c2VBcGkoKCkgPT4gYXBpQ2xpZW50LmFkbWluLmdldFBlbmRpbmdEb2N0b3JzKHBhcmFtcykpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBcHByb3ZlRG9jdG9yKCkge1xuICByZXR1cm4gdXNlQXBpTXV0YXRpb24oKGRhdGE6IHsgXG4gICAgZG9jdG9ySWQ6IHN0cmluZzsgXG4gICAgYWN0aW9uOiAnYXBwcm92ZScgfCAncmVqZWN0JzsgXG4gICAgcmVhc29uPzogc3RyaW5nOyBcbiAgICBhc3NpZ25QYXRpZW50cz86IGJvb2xlYW4gXG4gIH0pID0+IFxuICAgIGFwaUNsaWVudC5hZG1pbi5hcHByb3ZlRG9jdG9yKGRhdGEuZG9jdG9ySWQsIGRhdGEuYWN0aW9uLCBkYXRhLnJlYXNvbiwgZGF0YS5hc3NpZ25QYXRpZW50cylcbiAgKVxufVxuXG4vLyBEb2N0b3IgUmVnaXN0cmF0aW9uIEhvb2tcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWdpc3RlckRvY3RvcigpIHtcbiAgcmV0dXJuIHVzZUFwaU11dGF0aW9uKChkb2N0b3JEYXRhOiBhbnkpID0+IFxuICAgIGFwaUNsaWVudC5kb2N0b3IucmVnaXN0ZXIoZG9jdG9yRGF0YSlcbiAgKVxufVxuXG4vLyBIZWxwZXIgaG9vayBmb3IgcGFnaW5hdGlvblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhZ2luYXRpb24oaW5pdGlhbFBhZ2UgPSAxLCBpbml0aWFsTGltaXQgPSAxMCkge1xuICBjb25zdCBbcGFnZSwgc2V0UGFnZV0gPSB1c2VTdGF0ZShpbml0aWFsUGFnZSlcbiAgY29uc3QgW2xpbWl0LCBzZXRMaW1pdF0gPSB1c2VTdGF0ZShpbml0aWFsTGltaXQpXG5cbiAgY29uc3QgbmV4dFBhZ2UgPSAoKSA9PiBzZXRQYWdlKHByZXYgPT4gcHJldiArIDEpXG4gIGNvbnN0IHByZXZQYWdlID0gKCkgPT4gc2V0UGFnZShwcmV2ID0+IE1hdGgubWF4KDEsIHByZXYgLSAxKSlcbiAgY29uc3QgZ29Ub1BhZ2UgPSAobmV3UGFnZTogbnVtYmVyKSA9PiBzZXRQYWdlKE1hdGgubWF4KDEsIG5ld1BhZ2UpKVxuICBjb25zdCBjaGFuZ2VMaW1pdCA9IChuZXdMaW1pdDogbnVtYmVyKSA9PiB7XG4gICAgc2V0TGltaXQobmV3TGltaXQpXG4gICAgc2V0UGFnZSgxKSAvLyBSZXNldCB0byBmaXJzdCBwYWdlIHdoZW4gY2hhbmdpbmcgbGltaXRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGFnZSxcbiAgICBsaW1pdCxcbiAgICBuZXh0UGFnZSxcbiAgICBwcmV2UGFnZSxcbiAgICBnb1RvUGFnZSxcbiAgICBjaGFuZ2VMaW1pdCxcbiAgICBwYXJhbXM6IHsgcGFnZTogcGFnZS50b1N0cmluZygpLCBsaW1pdDogbGltaXQudG9TdHJpbmcoKSB9XG4gIH1cbn1cblxuLy8gSGVscGVyIGhvb2sgZm9yIHNlYXJjaFxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNlYXJjaChpbml0aWFsUXVlcnkgPSAnJykge1xuICBjb25zdCBbcXVlcnksIHNldFF1ZXJ5XSA9IHVzZVN0YXRlKGluaXRpYWxRdWVyeSlcbiAgY29uc3QgW2RlYm91bmNlZFF1ZXJ5LCBzZXREZWJvdW5jZWRRdWVyeV0gPSB1c2VTdGF0ZShpbml0aWFsUXVlcnkpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0RGVib3VuY2VkUXVlcnkocXVlcnkpXG4gICAgfSwgMzAwKSAvLyAzMDBtcyBkZWJvdW5jZVxuXG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lcilcbiAgfSwgW3F1ZXJ5XSlcblxuICByZXR1cm4ge1xuICAgIHF1ZXJ5LFxuICAgIGRlYm91bmNlZFF1ZXJ5LFxuICAgIHNldFF1ZXJ5LFxuICAgIGNsZWFyUXVlcnk6ICgpID0+IHNldFF1ZXJ5KCcnKVxuICB9XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJhcGlDbGllbnQiLCJ1c2VBcGkiLCJhcGlDYWxsIiwib3B0aW9ucyIsImltbWVkaWF0ZSIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJ0aW1lb3V0IiwiZW5hYmxlZCIsImRhdGEiLCJzZXREYXRhIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwidGltZWRPdXQiLCJzZXRUaW1lZE91dCIsImFib3J0Q29udHJvbGxlciIsInNldEFib3J0Q29udHJvbGxlciIsImxvYWRpbmdTdGFydFRpbWUiLCJzZXRMb2FkaW5nU3RhcnRUaW1lIiwiZmV0Y2hEYXRhIiwiY29uc29sZSIsImxvZyIsImFib3J0IiwibmV3QWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiRGF0ZSIsIm5vdyIsInRpbWVvdXRQcm9taXNlIiwiUHJvbWlzZSIsIl8iLCJyZWplY3QiLCJzZXRUaW1lb3V0IiwiRXJyb3IiLCJyZXNwb25zZSIsInJhY2UiLCJzaWduYWwiLCJhYm9ydGVkIiwic3VjY2VzcyIsImVycm9yTXNnIiwiZXJyIiwibmFtZSIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJyZWZldGNoIiwidXNlTG9hZGluZ1RpbWVvdXQiLCJpc0xvYWRpbmciLCJ0aW1lb3V0TXMiLCJoYXNUaW1lZE91dCIsInNldEhhc1RpbWVkT3V0IiwidGltZXIiLCJjbGVhclRpbWVvdXQiLCJ1c2VBcGlNdXRhdGlvbiIsIm11dGF0aW9uRm4iLCJtdXRhdGUiLCJ2YXJpYWJsZXMiLCJyZXNldCIsInVzZVVzZXJQcm9maWxlIiwidXNlciIsImdldFByb2ZpbGUiLCJ1c2VVcGRhdGVVc2VyUHJvZmlsZSIsInByb2ZpbGVEYXRhIiwidXBkYXRlUHJvZmlsZSIsInVzZVVwbG9hZEF2YXRhciIsImZpbGUiLCJ1cGxvYWRBdmF0YXIiLCJ1c2VEb2N0b3JQcm9maWxlIiwiZG9jdG9yIiwidXNlVXBkYXRlRG9jdG9yUHJvZmlsZSIsInVzZURvY3RvckF2YWlsYWJpbGl0eSIsImdldEF2YWlsYWJpbGl0eSIsInVzZVVwZGF0ZURvY3RvckF2YWlsYWJpbGl0eSIsImF2YWlsYWJpbGl0eURhdGEiLCJ1cGRhdGVBdmFpbGFiaWxpdHkiLCJ1c2VEb2N0b3JTZWFyY2giLCJwYXJhbXMiLCJzZWFyY2giLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwidXNlU3BlY2lhbGl6YXRpb25zIiwiZ2V0U3BlY2lhbGl6YXRpb25zIiwidXNlQWRtaW5Vc2VycyIsImFkbWluIiwiZ2V0VXNlcnMiLCJ1c2VVcGRhdGVVc2VyU3RhdHVzIiwidXBkYXRlVXNlclN0YXR1cyIsInVzZXJJZCIsImlzQWN0aXZlIiwicmVhc29uIiwidXNlVXNlckFuYWx5dGljcyIsInBlcmlvZCIsImdldFVzZXJBbmFseXRpY3MiLCJ1c2VQZW5kaW5nRG9jdG9ycyIsImdldFBlbmRpbmdEb2N0b3JzIiwidXNlQXBwcm92ZURvY3RvciIsImFwcHJvdmVEb2N0b3IiLCJkb2N0b3JJZCIsImFjdGlvbiIsImFzc2lnblBhdGllbnRzIiwidXNlUmVnaXN0ZXJEb2N0b3IiLCJkb2N0b3JEYXRhIiwicmVnaXN0ZXIiLCJ1c2VQYWdpbmF0aW9uIiwiaW5pdGlhbFBhZ2UiLCJpbml0aWFsTGltaXQiLCJwYWdlIiwic2V0UGFnZSIsImxpbWl0Iiwic2V0TGltaXQiLCJuZXh0UGFnZSIsInByZXYiLCJwcmV2UGFnZSIsIk1hdGgiLCJtYXgiLCJnb1RvUGFnZSIsIm5ld1BhZ2UiLCJjaGFuZ2VMaW1pdCIsIm5ld0xpbWl0IiwidG9TdHJpbmciLCJ1c2VTZWFyY2giLCJpbml0aWFsUXVlcnkiLCJxdWVyeSIsInNldFF1ZXJ5IiwiZGVib3VuY2VkUXVlcnkiLCJzZXREZWJvdW5jZWRRdWVyeSIsImNsZWFyUXVlcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/hooks/useApi.ts\n"));

/***/ })

});